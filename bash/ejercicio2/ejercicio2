#!/bin/bash


MATRIZ=""
SEPARADOR="|"
CAMINO=0
HUB=0  
AYUDA=0
INF=1e300  # “infinito” para inicializar distancias

# ================== VARIABLES GLOBALES ================== 
declare -A MAT # Matriz asociativa con posiciones I J para Fila Columna "-A"
declare -a dist visit
declare -a prev_parents

# ================== FUNCIONES ==================
# ================== HELPERS ==================
# Suma de flotantes
f_add() { awk -v a="$1" -v b="$2" 'BEGIN{printf "%.15g\n", a+b}'; }

# a < b con tolerancia (evita problemas por redondeo)
f_lt()  { awk -v a="$1" -v b="$2" 'BEGIN{eps=1e-9; exit !(a < b - eps)}'; }

# a == b con tolerancia
f_eq()  { awk -v a="$1" -v b="$2" 'BEGIN{eps=1e-9; d=a-b; if (d<0) d=-d; exit !(d<eps)}'; }

# Comparación numérica flotante: retorna 0 si x>0, 1 si no
es_pos() { awk -v x="$1" 'BEGIN{exit !(x>0)}'; }  # usar: if es_pos "$v"; then ...

function abspath_dir() {
  # Resuelve .. de un DIRECTORIO existente
  local d="$1"
  case "$d" in
    /*|~*) printf '%s\n' "$d" ;;
    *)     ( cd "$d" 2>/dev/null && pwd ) || return 1 ;;
  esac
}
function abspath_file() {
  # Convierte RUTA DE ARCHIVO (que puede no existir) a absoluta
  # resolviendo el directorio padre
  local f="$1"
  local dir base
  dir=$(dirname -- "$f")
  base=$(basename -- "$f")
  dir=$(abspath_dir "$dir") || return 1
  printf '%s/%s\n' "$dir" "$base"
}

dijkstra_desde() {  # $1 = origen s (0..N-1)
  local s="$1"
  dist=(); visit=(); prev_parents=()

  # 1) inicialización
  for ((i=0;i<N;i++)); do
    dist[$i]="$INF"
    visit[$i]=0
    prev_parents[$i]=""   # lista de posibles padres
  done
  dist[$s]=0

  # 2) N iteraciones: elegir el no visitado con menor dist y relajar vecinos
  for ((k=0;k<N;k++)); do
    # 2a) elegir u
    local u=-1 best="$INF"
    for ((i=0;i<N;i++)); do
      if [[ ${visit[$i]} -eq 0 ]] && f_lt "${dist[$i]}" "$best"; then
        u=$i; best="${dist[$i]}"
      fi
    done
    [[ $u -lt 0 ]] && break  # no quedan alcanzables

    visit[$u]=1

    # 2b) relajar u -> v
    for ((v=0; v<N; v++)); do
      (( u==v )) && continue
      local w="${MAT["$u,$v"]}"
      if es_pos "$w"; then               # hay arista si w>0
        local new; new=$(f_add "${dist[$u]}" "$w")
        if f_lt "$new" "${dist[$v]}"; then
          dist[$v]="$new"
          prev_parents[$v]="$u"          # reemplaza padres
        elif f_eq "$new" "${dist[$v]}"; then
          prev_parents[$v]="${prev_parents[$v]} $u"   # agrega padre (empate)
        fi
      fi
    done
  done
}

# Imprime cada camino como "s ... t" (índices 0-based, después los embellecemos)
reconstruir_caminos() {  # $1=s $2=t $3=acum_en_orden_inverso
  local s="$1" t="$2" acum="$3"

  if [[ $t -eq $s ]]; then
    echo "$t $acum"
    return
  fi

  for p in ${prev_parents[$t]}; do
    [[ -z "$p" ]] && continue
    reconstruir_caminos "$s" "$p" "$t $acum"
  done
}

# ================== FUNCIONES DE CODIGO ==================
function ayuda() {
  cat <<'EOF'

Analiza una red de transporte modelada como matriz de adyacencia.
Puede:
  - Determinar el o los HUBS (estación/es con más conexiones), o
  - Calcular el/los caminos más cortos (Dijkstra).

REQUISITOS (consigna):
  • La salida se guarda en "informe.<nombreArchivoEntrada>" en el MISMO directorio
    del archivo original.  (p. ej.: /ruta/mapa.txt -> /ruta/informe.mapa.txt)
  • La matriz debe ser cuadrada, simétrica y numérica.

USO:
  $0 -m|--matriz <archivo>  [-s|--separador <caracter>]  (-c|--camino | -h|--hub)
  $0 -H | --help

PARÁMETROS:
  -m, --matriz      Ruta del archivo de la matriz (obligatorio). Acepta relativa o absoluta.
  -s, --separador   Separador de columnas (opcional). Default: "|" (pipe).
                    Para tabulador, usá: $'\t'
  -c, --camino      Calcula camino(s) más corto(s) (mutuamente excluyente con --hub).
  -h, --hub         Determina la estación HUB (mutuamente excluyente con --camino).
  -H, --help        Muestra esta ayuda y termina.

REGLAS:
  • Debe pasarse -m y EXACTAMENTE una de -c o -h.
  • La salida se escribe en el mismo directorio que la matriz con prefijo "informe.".
  • Los errores y mensajes se envían a stderr; la salida útil al archivo indicado.

EJEMPLOS:
  # HUB con separador por defecto (pipe)
  $0 -m ./datos/mapa_transporte.txt --hub

  # Camino más corto usando ";" como separador
  $0 --matriz /tmp/mapa.csv --separador ';' --camino

EOF
  exit 0
}


camino() {
  local max_global="-1"
  local -a PARES_MAX=()

  for ((s=0; s<N; s++)); do
    dijkstra_desde "$s"
    for ((t=0; t<N; t++)); do
      (( t == s )) && continue
      # descartar no alcanzables
      if ! f_eq "${dist[$t]}" "$INF"; then
        if f_lt "$max_global" "${dist[$t]}"; then    # dist > max_global
          max_global="${dist[$t]}"
          PARES_MAX=( "$s,$t" )
        elif f_eq "${dist[$t]}" "$max_global"; then  # empate
          PARES_MAX+=( "$s,$t" )
        fi
      fi
    done
  done

  {
    echo "## Informe de análisis de red de transporte"
    echo "**Camino(s) más corto(s) de punta a punta (diámetro):**"
    echo "**Tiempo total:** $max_global"
    echo "**Rutas (estaciones 1..$N):**"
  } > "$SALIDA"

  for par in "${PARES_MAX[@]}"; do
    IFS=',' read -r s t <<< "$par"
    dijkstra_desde "$s"
    while IFS= read -r path; do
      pretty=$(awk '{
        out=""; for(i=1;i<=NF;i++){ if(i>1) out=out" -> "; out=out"" ($i+1) } print out
      }' <<< "$path")
      echo "- $pretty" >> "$SALIDA"
    done < <(reconstruir_caminos "$s" "$t" "")
  done

  echo "Informe escrito en: $SALIDA"
}





function resolver_hub() {
  local -a DEG              # DEG[i] = conexiones de la estación i
  local max=-1
  local i j v

  # Contar conexiones por fila (grado)
  for ((i=0; i<N; i++)); do
    DEG[$i]=0
    for ((j=0; j<N; j++)); do
      (( i == j )) && continue           # ignorar diagonal
      v=${MAT["$i,$j"]}
      if es_pos "$v"; then               # cuenta si v > 0 (soporta decimales)
        (( DEG[$i]++ ))
      fi
    done
    (( DEG[$i] > max )) && max=${DEG[$i]}
  done

  # Recolectar TODAS las estaciones con grado == max
  local -a HUBS=()
  for ((i=0; i<N; i++)); do
    (( DEG[$i] == max )) && HUBS+=( "$i" )
  done

  # Mostrar/usar el resultado (estaciones 1..N para el informe)
  echo "**Hub de la red:** ($max conexiones):"
  for idx in "${HUBS[@]}"; do
    echo "  - Estación $((idx+1))"
  done
}

function validar_y_cargar_matriz() {
  local archivo="$1" sep="$2"

  [[ -f "$archivo" ]] || { echo "Error: no existe archivo $archivo" >&2; return 1; }

  
  local fila=0 cols_esperadas=-1

  while IFS= read -r linea || [[ -n "$linea" ]]; do
    IFS="$sep" read -r -a celdas <<< "$linea"
    local cols=${#celdas[@]}

    # Definir cantidad de columnas esperadas
    if (( cols_esperadas < 0 )); then
      cols_esperadas=$cols
    fi

    # Verificar que la fila tiene la misma cantidad de columnas
    if (( cols != cols_esperadas )); then
      echo "Error: fila $((fila+1)) tiene $cols columnas, se esperaban $cols_esperadas" >&2
      return 2
    fi

    # Verificar que cada valor sea numérico y no negativo
    for v in "${celdas[@]}"; do
      if ! [[ "$v" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
        echo "Error: valor no numérico en fila $((fila+1)): '$v'" >&2
        return 3
      fi
    done

    # Cargar provisionalmente en la matriz
    for ((col=0; col<cols; col++)); do
      MAT["$fila,$col"]="${celdas[$col]}"
    done
    ((fila++))
  done < <(tr -d '\r' < "$archivo") # Usamos esto para elimiar el carriage return del formato de archivo windows
  #Si el archivo viene de linux solamente se usa el \n, entonces si queremos eliminar el \r no pasa nada porque no hay
  
  # Verificar que es cuadrada
  if (( fila != cols_esperadas )); then
    echo "Error: matriz no es cuadrada (${fila}x${cols_esperadas})" >&2
    return 4
  fi

  N=$fila

  # Verificar simetría
  for ((i=0; i<N; i++)); do
    for ((j=0; j<N; j++)); do
      if [[ "${MAT["$i,$j"]}" != "${MAT["$j,$i"]}" ]]; then
        echo "Error: matriz no simétrica en posición ($i,$j)" >&2
        return 5
      fi
    done
  done

  echo "OK: matriz ${N}x${N} validada y cargada"
  return 0
}

options=$(getopt -o m:s:c,h,H -l matriz:,separador:,camino,hub,help -- "$@") || {
  echo "Uso: $0 -d <directorio> [-a <archivo> | -p]
Para mas detalles sobre el script usar -h | --help"; exit 2; }

eval set -- "$options"

while true; do
  case "$1" in
    -m|--matriz)       MATRIZ="$(abspath_file "$2")"; shift 2 ;;
    -s|--separador)    SEPARADOR="$2"; shift 2 ;;
    -c|--camino)       CAMINO=1; shift ;;
    -h|--hub)          HUB=1; shift ;;
    -H|--help)         ayuda ;;
    --)                shift; break ;;
    *)                 echo "Opción inválida: $1" >&2; exit 2 ;;
  esac
done


# ================== VALIDACIONES ==================
# Archivo obligatorio y existente
if [ -z "$MATRIZ" ] || [ ! -f "$MATRIZ" ]; then
  echo "Error: faltó -m/--matriz o no existe: $MATRIZ" >&2
  exit 1
fi

# Exclusión -a / -p
if [ "$CAMINO" -eq 1 ] && [ "$HUB" -eq 1 ]; then
  echo "Error: -c/--camino y -h/--hub son excluyentes." >&2
  exit 1
fi

# Si no dieron ni -a ni -p → pedimos archivo
if [ "$CAMINO" -eq 0 ] && [ "$HUB" -eq 0 ]; then
  echo "Debe eligar al menos una opcion -c|--camino ó -h|--hub para ejecutar el script" 
  echo "Para mas informacion utilice el comando -H|--help"
  exit 1
fi

validar_y_cargar_matriz "$MATRIZ" "$SEPARADOR"

# ================== SALIDA ==================
# Separar directorio y nombre de archivo
dir=$(dirname -- "$MATRIZ")
base=$(basename -- "$MATRIZ")

# Construir ruta de salida
SALIDA="$dir/informe.$base"



if [ "$CAMINO" -eq 1 ]; then
  camino
fi

if [ "$HUB" -eq 1 ]; then
  {
    echo "##Informe de analisis de red de transporte ## "
    resolver_hub
  } > "$SALIDA"
  
fi




#Imprimimos variables para controlar los valores correctamente 
echo "Matriz: "$MATRIZ 
echo "Separador: "$SEPARADOR
echo "Camino: "$CAMINO 
echo "HUB: "$HUB 
echo "Ayuda: "$AYUDA 
echo "Salida: "$SALIDA


