#!/bin/bash


MATRIZ=""
SEPARADOR="|"
CAMINO=0
HUB=0  
AYUDA=0
INF=1e300  # “infinito” para inicializar distancias
MEJOR_COSTO="$INF"
# ================== VARIABLES GLOBALES ================== 
declare -A MAT # Matriz asociativa con posiciones I J para Fila Columna "-A"
declare -a dist visit orden prev_parents parent_best MEJORES_ORDENES
declare -A D  # D["i,j"] = distancia mínima entre i y j


# ================== FUNCIONES ==================
# ================== HELPERS ==================
# Suma de flotantes
f_add() { awk -v a="$1" -v b="$2" 'BEGIN{printf "%.15g\n", a+b}'; }

# a < b con tolerancia (evita problemas por redondeo)
f_lt()  { awk -v a="$1" -v b="$2" 'BEGIN{eps=1e-9; exit !(a < b - eps)}'; }

# a == b con tolerancia
f_eq()  { awk -v a="$1" -v b="$2" 'BEGIN{eps=1e-9; d=a-b; if (d<0) d=-d; exit !(d<eps)}'; }

# Comparación numérica flotante: retorna 0 si x>0, 1 si no
es_pos() { awk -v x="$1" 'BEGIN{exit !(x>0)}'; }  # usar: if es_pos "$v"; then ...

function abspath_dir() {
  # Resuelve .. de un DIRECTORIO existente
  local d="$1"
  case "$d" in
    /*|~*) printf '%s\n' "$d" ;;
    *)     ( cd "$d" 2>/dev/null && pwd ) || return 1 ;;
  esac
}
function abspath_file() {
  # Convierte RUTA DE ARCHIVO (que puede no existir) a absoluta
  # resolviendo el directorio padre
  local f="$1"
  local dir base
  dir=$(dirname -- "$f")
  base=$(basename -- "$f")
  dir=$(abspath_dir "$dir") || return 1
  printf '%s/%s\n' "$dir" "$base"
}

dijkstra_desde() {  # $1 = origen
  local s="$1"
  dist=(); visit=(); prev_parents=(); parent_best=()
  for ((i=0;i<N;i++)); do
    dist[$i]="$INF"; visit[$i]=0; prev_parents[$i]=""; parent_best[$i]=-1
  done
  dist[$s]=0
  parent_best[$s]=-1

  for ((k=0;k<N;k++)); do
    local u=-1 best="$INF"
    for ((i=0;i<N;i++)); do
      if [[ ${visit[$i]} -eq 0 ]] && f_lt "${dist[$i]}" "$best"; then
        u=$i; best="${dist[$i]}"
      fi
    done
    [[ $u -lt 0 ]] && break
    visit[$u]=1

    for ((v=0; v<N; v++)); do
      (( u==v )) && continue
      local w="${MAT["$u,$v"]}"
      if es_pos "$w"; then
        local new; new=$(f_add "${dist[$u]}" "$w")
        if f_lt "$new" "${dist[$v]}"; then
          dist[$v]="$new"
          prev_parents[$v]="$u"
          parent_best[$v]="$u"     # <<< padre “seguro”
        elif f_eq "$new" "${dist[$v]}"; then
          prev_parents[$v]="${prev_parents[$v]} $u"  # (por si más adelante querés “todas”)
          # parent_best se mantiene (ya es válido)
        fi
      fi
    done
  done
}

# Devuelve UNA ruta s..t (0-based) usando prev_parents,
# priorizando el primer padre que encuentre.
reconstruir_un_camino() {  # $1=s $2=t
  local s="$1" t="$2"
  # si no hay ruta
  if f_eq "${dist[$t]}" "$INF"; then
    return 1
  fi
  local cur="$t"
  local stack=()
  while [[ $cur -ne -1 ]]; do
    stack+=( "$cur" )
    [[ $cur -eq $s ]] && break
    cur="${parent_best[$cur]}"
    # si por alguna razón quedó sin padre y no llegamos a s → no hay camino
    [[ $cur -eq -1 ]] && return 1
  done

  # invertir (para s..t)
  local out=()
  for ((i=${#stack[@]}-1; i>=0; i--)); do out+=( "${stack[$i]}" ); done
  echo "${out[*]}"
}

precalcular_todas_las_distancias() {
  for ((s=0; s<N; s++)); do
    dijkstra_desde "$s"
    for ((t=0; t<N; t++)); do
      D["$s,$t"]="${dist[$t]}"
    done
  done
}

buscar_ordenes_minimos_bt() {  # $1=profundidad $2=costo_parcial
  local k="$1" costo="$2"

  # poda
  if f_lt "$MEJOR_COSTO" "$costo"; then
    return
  fi

  if (( k == N )); then
    # alcanzamos una permutación completa
    if f_lt "$costo" "$MEJOR_COSTO"; then
      MEJOR_COSTO="$costo"
      MEJORES_ORDENES=()
    fi
    if f_eq "$costo" "$MEJOR_COSTO"; then
      # guardar orden actual (como línea)
      local line=""
      for ((i=0;i<N;i++)); do
        line+="${orden[$i]},"
      done
      line="${line%,}"                 # saca la coma final
      MEJORES_ORDENES+=( "$line" )
    fi
    return
  fi

  for ((v=0; v<N; v++)); do
    if [[ "${visit[$v]}" -eq 0 ]]; then
      # si no es el primero, sumo el costo D[prev, v]
      local extra="0"
      if (( k > 0 )); then
        local prev="${orden[$((k-1))]}"
        local d="${D["$prev,$v"]}"
        # si no alcanzable, descartar rama
        if f_eq "$d" "$INF"; then
          continue
        fi
        extra="$d"
      fi

      visit[$v]=1
      orden[$k]="$v"

      local nuevo; nuevo=$(f_add "$costo" "$extra")
      buscar_ordenes_minimos_bt "$((k+1))" "$nuevo"

      visit[$v]=0
    fi
  done
}

# ================== FUNCIONES DE CODIGO ==================
function ayuda() {
  cat <<'EOF'

Analiza una red de transporte modelada como matriz de adyacencia.
Puede:
  - Determinar el o los HUBS (estación/es con más conexiones), o
  - Calcular el/los caminos más cortos (Dijkstra).

REQUISITOS (consigna):
  • La salida se guarda en "informe.<nombreArchivoEntrada>" en el MISMO directorio
    del archivo original.  (p. ej.: /ruta/mapa.txt -> /ruta/informe.mapa.txt)
  • La matriz debe ser cuadrada, simétrica y numérica.

USO:
  $0 -m|--matriz <archivo>  [-s|--separador <caracter>]  (-c|--camino | -h|--hub)
  $0 -H | --help

PARÁMETROS:
  -m, --matriz      Ruta del archivo de la matriz (obligatorio). Acepta relativa o absoluta.
  -s, --separador   Separador de columnas (opcional). Default: "|" (pipe).
                    Para tabulador, usá: $'\t'
  -c, --camino      Calcula camino(s) más corto(s) (mutuamente excluyente con --hub).
  -h, --hub         Determina la estación HUB (mutuamente excluyente con --camino).
  -H, --help        Muestra esta ayuda y termina.

REGLAS:
  • Debe pasarse -m y EXACTAMENTE una de -c o -h.
  • La salida se escribe en el mismo directorio que la matriz con prefijo "informe.".
  • Los errores y mensajes se envían a stderr; la salida útil al archivo indicado.

EJEMPLOS:
  # HUB con separador por defecto (pipe)
  $0 -m ./datos/mapa_transporte.txt --hub

  # Camino más corto usando ";" como separador
  $0 --matriz /tmp/mapa.csv --separador ';' --camino

EOF
  exit 0
}


camino() {
  precalcular_todas_las_distancias   # como ya lo tenías

  MEJOR_COSTO="$INF"; MEJORES_ORDENES=()
  visit=(); orden=(); for ((i=0;i<N;i++)); do visit[$i]=0; done
  buscar_ordenes_minimos_bt 0 0      # como ya lo tenías

  {
    echo "## Informe de análisis de red de transporte"
    echo "**Recorrido(s) más rápido(s) que visitan todas las estaciones (0..N-1):**"
    echo "**Costo total mínimo:** $MEJOR_COSTO"
    echo "**Ruta(s) (estaciones 1..$N):**"
  } > "$SALIDA"

  for line in "${MEJORES_ORDENES[@]}"; do
    local OLDIFS="$IFS"
    echo "DBG ord=(${ord[*]})" >&2
    echo "DBG tramo $((s+1))->$((t+1)) = '$tramo'" >&2
    IFS=',' read -r -a ord <<< "$line"
    read -r -a ord <<< "$line"
    IFS="$OLDIFS"

    ruta_completa=()
    for ((i=0;i<N-1;i++)); do
      s="${ord[$i]}"; t="${ord[$((i+1))]}"
      dijkstra_desde "$s"                       # llena parent_best[] válido para s→t
      local tramo
      tramo="$(reconstruir_un_camino "$s" "$t")" || {
      echo "Advertencia: la red no es conexa para $((s+1))→$((t+1))" >&2
      continue
      }
      # split del tramo por espacios:
      OLDIFS="$IFS"; IFS=$' \t\n'
      echo "DBG ord=(${ord[*]})" >&2
      echo "DBG tramo $((s+1))->$((t+1)) = '$tramo'" >&2

      read -r -a nodes <<< "$tramo"
      IFS="$OLDIFS"
      if (( i == 0 )); then
        ruta_completa+=( "${nodes[@]}" )
      else
        for ((k=1;k<${#nodes[@]};k++)); do
          ruta_completa+=( "${nodes[$k]}" )
        done
      fi
    done

    pretty=$(awk '{
      out=""; for(i=1;i<=NF;i++){ if(i>1) out=out" -> "; out=out"" ($i+1) } print out
    }' <<< "${ruta_completa[*]}")
    echo "- $pretty" >> "$SALIDA"
  done

  echo "Informe escrito en: $SALIDA"
}

function resolver_hub() {
  local -a DEG              # DEG[i] = conexiones de la estación i
  local max=-1
  local i j v

  # Contar conexiones por fila (grado)
  for ((i=0; i<N; i++)); do
    DEG[$i]=0
    for ((j=0; j<N; j++)); do
      (( i == j )) && continue           # ignorar diagonal
      v=${MAT["$i,$j"]}
      if es_pos "$v"; then               # cuenta si v > 0 (soporta decimales)
        (( DEG[$i]++ ))
      fi
    done
    (( DEG[$i] > max )) && max=${DEG[$i]}
  done

  # Recolectar TODAS las estaciones con grado == max
  local -a HUBS=()
  for ((i=0; i<N; i++)); do
    (( DEG[$i] == max )) && HUBS+=( "$i" )
  done

  # Mostrar/usar el resultado (estaciones 1..N para el informe)
  echo "**Hub de la red:** ($max conexiones):"
  for idx in "${HUBS[@]}"; do
    echo "  - Estación $((idx+1))"
  done
}

function validar_y_cargar_matriz() {
  local archivo="$1" sep="$2"

  [[ -f "$archivo" ]] || { echo "Error: no existe archivo $archivo" >&2; return 1; }

  
  local fila=0 cols_esperadas=-1
  local OLDIFS="$IFS" 

  while IFS= read -r linea || [[ -n "$linea" ]]; do
    local IFS="$sep"
    read -r -a celdas <<< "$linea"
    local cols=${#celdas[@]}

    # Definir cantidad de columnas esperadas
    if (( cols_esperadas < 0 )); then
      cols_esperadas=$cols
    fi

    # Verificar que la fila tiene la misma cantidad de columnas
    if (( cols != cols_esperadas )); then
      echo "Error: fila $((fila+1)) tiene $cols columnas, se esperaban $cols_esperadas" >&2
      return 2
    fi

    # Verificar que cada valor sea numérico y no negativo
    for v in "${celdas[@]}"; do
      if ! [[ "$v" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
        echo "Error: valor no numérico en fila $((fila+1)): '$v'" >&2
        return 3
      fi
    done

    # Cargar provisionalmente en la matriz
    for ((col=0; col<cols; col++)); do
      MAT["$fila,$col"]="${celdas[$col]}"
    done
    ((fila++))
  done < <(tr -d '\r' < "$archivo") # Usamos esto para elimiar el carriage return del formato de archivo windows
  #Si el archivo viene de linux solamente se usa el \n, entonces si queremos eliminar el \r no pasa nada porque no hay
  IFS="$OLDIFS"
  # Verificar que es cuadrada
  if (( fila != cols_esperadas )); then
    echo "Error: matriz no es cuadrada (${fila}x${cols_esperadas})" >&2
    return 4
  fi

  N=$fila

  # Verificar simetría
  for ((i=0; i<N; i++)); do
    for ((j=0; j<N; j++)); do
      if [[ "${MAT["$i,$j"]}" != "${MAT["$j,$i"]}" ]]; then
        echo "Error: matriz no simétrica en posición ($i,$j)" >&2
        return 5
      fi
    done
  done

  echo "OK: matriz ${N}x${N} validada y cargada"
  return 0
}

options=$(getopt -o m:s:c,h,H -l matriz:,separador:,camino,hub,help -- "$@") || {
  echo "Uso: $0 -d <directorio> [-a <archivo> | -p]
Para mas detalles sobre el script usar -h | --help"; exit 2; }

eval set -- "$options"

while true; do
  case "$1" in
    -m|--matriz)       MATRIZ="$(abspath_file "$2")"; shift 2 ;;
    -s|--separador)    SEPARADOR="$2"; shift 2 ;;
    -c|--camino)       CAMINO=1; shift ;;
    -h|--hub)          HUB=1; shift ;;
    -H|--help)         ayuda ;;
    --)                shift; break ;;
    *)                 echo "Opción inválida: $1" >&2; exit 2 ;;
  esac
done


# ================== VALIDACIONES ==================
# Archivo obligatorio y existente
if [ -z "$MATRIZ" ] || [ ! -f "$MATRIZ" ]; then
  echo "Error: faltó -m/--matriz o no existe: $MATRIZ" >&2
  exit 1
fi

# Exclusión -a / -p
if [ "$CAMINO" -eq 1 ] && [ "$HUB" -eq 1 ]; then
  echo "Error: -c/--camino y -h/--hub son excluyentes." >&2
  exit 1
fi

# Si no dieron ni -a ni -p → pedimos archivo
if [ "$CAMINO" -eq 0 ] && [ "$HUB" -eq 0 ]; then
  echo "Debe eligar al menos una opcion -c|--camino ó -h|--hub para ejecutar el script" 
  echo "Para mas informacion utilice el comando -H|--help"
  exit 1
fi

validar_y_cargar_matriz "$MATRIZ" "$SEPARADOR"

# ================== SALIDA ==================
# Separar directorio y nombre de archivo
dir=$(dirname -- "$MATRIZ")
base=$(basename -- "$MATRIZ")

# Construir ruta de salida
SALIDA="$dir/informe.$base"



if [ "$CAMINO" -eq 1 ]; then
  camino
fi

if [ "$HUB" -eq 1 ]; then
  {
    echo "##Informe de analisis de red de transporte ## "
    resolver_hub
  } > "$SALIDA"
  
fi




#Imprimimos variables para controlar los valores correctamente 
echo "Matriz: "$MATRIZ 
echo "Separador: "$SEPARADOR
echo "Camino: "$CAMINO 
echo "HUB: "$HUB 
echo "Ayuda: "$AYUDA 
echo "Salida: "$SALIDA


